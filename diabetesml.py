# -*- coding: utf-8 -*-
"""diabetesml.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AvGf9VMfp-MWWCT5P_EhIVRrRSBFABzX
"""

import pandas as pd
import numpy as np

from math import ceil
import matplotlib.pyplot as plt
import seaborn as sns
import os

from google.colab import drive
from google.colab import data_table

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import cross_val_score

import warnings
warnings.filterwarnings('ignore')

"""Install library dari luar dimana disini saya menginstall dari kaggle"""

!pip install kaggle

drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
os.environ['KAGGLE_CONFIG_DIR'] = '/content/gdrive/MyDrive/Kaggle'
# %cd /content/gdrive/MyDrive/Kaggle

!kaggle datasets download -d iammustafatz/diabetes-prediction-dataset

data = pd.read_csv('/content/gdrive/MyDrive/Kaggle/diabetes_prediction_dataset.csv')

data.info()

"""Diabetes adalah variabel target yang diprediksi, dengan nilai 1 menunjukkan adanya diabetes dan 0 menunjukkan tidak"""

data.shape

"""Dataset mengandung 100.000 record dan 9 kolom

Mengecek apaka ada nilai null atau tidak
"""

data.isnull().sum()

"""Menampilkan data teratas pada dataframe"""

data.head()

"""Feature Gender (Jenis Kelamin)"""

plt.figure(figsize=(7,5))
sns.set(font_scale=2)
sns.countplot(x='gender',data=data);
plt.title("Distribution of Gender Feature");

"""Menghitung banyaknya gender female dan male"""

data.gender.value_counts()

"""Sehingga didapat bahwa ada 58552 Female dan 41430 Male pada dataset ini

Membuat plot tentang penyebaran diabetes berdasarkan dari riwayat merokok(smoking_history) yang mengacu pada jenis kelamin(gender)
"""

plt.figure(figsize=(10,5));
sns.set(font_scale=2)
sns.countplot(x='gender',data=data,hue='smoking_history');
plt.legend(loc="upper right");
plt.title("Distribution of Gender feature based on smoking history");

"""Membuat plot penyebaran diabetes berdasarkan riwayat merokok yang mengacu pada jenis kelamin(gender)"""

plt.figure(figsize=(10,5));
sns.countplot(x='gender',data=data,hue='diabetes');
plt.legend(loc="upper right");
plt.title("Distribution of Gender feature based on smoking history");

"""Menyaring data dimana 'diabetes' bernilai 1"""

diabetes_data = data[data['diabetes'] == 1]

plt.figure(figsize=(10,5));
sns.countplot(x='gender', data=diabetes_data)
plt.title("Count of diabetes patients based on gender");

"""Dari graf diatas dapat disimpulkan bahwa pasien diabetes wanita jauh lebih banyak dibanding dengan pasien laki laki.

Membuat plot penyebaran diabetes berdasarkan usia
"""

plt.hist(data['age']);
plt.title('Age Distribution')
plt.xlabel('Age')
plt.ylabel('Frequency')
plt.show()

"""Membuat pie chart yang berisi persentase orang-orang yang memiliki hipertensi"""

hypertension_counts = data['hypertension'].value_counts()
hypertension_percentage = hypertension_counts / len(data) * 100

plt.figure(figsize=(10,6))
labels = ['No Hypertension', 'Hypertension']
plt.pie(hypertension_percentage, labels=labels, autopct='%1.1f%%')

plt.title('Percentage of People with Hypertension')

plt.show()

"""Kasus diabetes yang dikelompokan berdasarkan dari riwayat merokok"""

grouped_data = data.groupby('smoking_history')['diabetes'].mean()

plt.figure(figsize=(12,8))
plt.bar(grouped_data.index, grouped_data.values)

plt.title('Proportion of Diabetes Cases by Smoking History')
plt.xlabel('Smoking History')
plt.ylabel('Proportion of Diabetes Cases')

plt.show()

"""Membagi data menjadi x dan y"""

X = data.drop('diabetes',axis=1)
y = data.diabetes

"""Membagi data latih dan data uji"""

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.3,random_state=43)

"""Data latih menjadi 70% dan data uji sebanyak 30%"""

X_train.shape,X_test.shape

"""Data Encoding, mengubah data kategorikal menjadi numerik"""

def encode_gender(label):
    if label == 'Female':
        return 0
    elif label == 'Male':
        return 1
    else:
        return 2

X_train.gender = X_train.gender.apply(encode_gender)
X_test.gender = X_test.gender.apply(encode_gender)

def encoder_smoking(label):
    if label == 'No Info':
        return 0
    elif label == 'never':
        return 1
    elif label == 'former':
        return 2
    elif label == 'current':
        return 3
    elif label == 'not current':
        return 4
    else:
        return 5

X_train['smoking_history'] = X_train['smoking_history'].apply(encoder_smoking)
X_test['smoking_history'] = X_test['smoking_history'].apply(encoder_smoking)

X_train.head()

"""Feature Selection"""

plt.figure(figsize=(12,10))
cor = X_train.corr()
sns.heatmap(cor,annot=True,cmap=plt.cm.CMRmap_r);
plt.show();

"""Dari heatmap diatas dapat disimpulkan bahwa tidak ada fitur yang berkorelasi tinggi satu sama lain."""

from sklearn.feature_selection import VarianceThreshold
var_thres = VarianceThreshold(threshold=0)
var_thres.fit(X_train)

const_cols = [column for column in X_train.columns if column not in X_train.columns[var_thres.get_support()]]

const_cols

"""Setelah menggunakan VarianceThreshold pada data latih, dapat dilihat bahwa tidak ada fitur yang memiliki varians rendah.

Menangani data yang tidak seimbang
"""

sns.countplot(x='diabetes',data=data);

"""Menurut count plot di atas, dataset yang digunakan tidak seimbang.
Maksud dari dataset yang tidak seimbang adalah satu kelas atau kategori memiliki jumlah contoh yang jauh lebih besar daripada kelas lain dalam dataset, sehingga disebut sebagai dataset yang tidak seimbang.

Karena dataset yang tidak seimbang maka digunakan SMOTE
"""

from imblearn.over_sampling import SMOTE
oversampler = SMOTE()
X_over, y_over = oversampler.fit_resample(X_train, y_train)

"""SMOTE (Synthetic Minority Over-sampling Technique) adalah teknik pengambilan sampel berlebih yang populer yang digunakan untuk mengatasi ketidakseimbangan kelas dalam set data.
SMOTE membantu mengatasi masalah ketidakseimbangan kelas dengan meningkatkan jumlah instance dalam kelas minoritas.
"""

X_over.shape,y_over.shape

scalar = StandardScaler()

"""Sesuaikan scaler pada data latih dan ubah data latih dan data uji"""

X_over_scaled = scalar.fit_transform(X_over)
X_test_scaled = scalar.transform(X_test)

"""# Pelatihan Model"""

model_names = []
accuracies = []

"""# Logistic Regression"""

log_reg = LogisticRegression(max_iter=2000)
log_reg.fit(X_over_scaled,y_over)
model_names.append('Logistic Regression')
accuracies.append(ceil(log_reg.score(X_test_scaled,y_test)*100))
y_pred = log_reg.predict(X_test_scaled)
print(classification_report(y_test,y_pred))

"""K nearest neighbor (KNN)"""

accuracy_rate = []
for i in range(1,16,2):
    knn = KNeighborsClassifier(n_neighbors=i)
    score = cross_val_score(knn,X_over_scaled,y_over,cv=3)
    accuracy_rate.append(score.mean())

"""Memilih nilai K"""

plt.figure(figsize=(10,6))
plt.plot(range(1,16,2),accuracy_rate,color='blue', linestyle='dashed', marker='o',
         markerfacecolor='red', markersize=10)
plt.title('Accuracy Rate vs. K Value')
plt.xlabel('K');
plt.ylabel('Accuracy Rate');

knn = KNeighborsClassifier(n_neighbors=2)
knn.fit(X_over_scaled,y_over)
model_names.append('KNeighborsClassifier')
accuracies.append(ceil(knn.score(X_test_scaled,y_test)*100))
y_pred = knn.predict(X_test_scaled)
print(classification_report(y_test,y_pred))

"""Decision tree"""

parameter = {
    'criterion':["gini", "entropy", "log_loss"],
    'splitter' :["best", "random"],
    'max_depth':[1,2,3,4,5],
    'max_features':["auto", "sqrt", "log2"],
    'ccp_alpha':[1,2,3,4,5,6,7]
}

treemodel = DecisionTreeClassifier(max_depth=2)
cv = GridSearchCV(treemodel,param_grid=parameter,cv=5,scoring='accuracy')

cv.fit(X_over_scaled,y_over)

cv.best_params_

y_pred = cv.predict(X_test_scaled)

model_names.append('Decision Tree')
accuracies.append(ceil(cv.score(X_test_scaled,y_test)*100))

print(classification_report(y_test,y_pred))

"""Membuat plot hasil perbandingan akurasi dari model yang digunakan

"""

plt.figure(figsize=(13,6));
plt.bar(model_names, accuracies);

plt.title('Model Accuracy')
plt.xlabel('Model')
plt.ylabel('Accuracy')

plt.show()

"""Dari Plot di atas dapat dilihat bahwa model KNN adalah memiliki nilai akurasi tertinggi dibanding dengan Logistic Regression dan Decision Tree."""